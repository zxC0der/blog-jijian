---
draft: true
---

## 什么是事务?

事务是逻辑上的一组操作，要么都执行，要么都不执行。

## 事务的四个特性(ACID)

原子性: 事务是最小的执行单位。
一致性: 执行事务前后，数据都是处于一致性状态，即该状态满足预定的约束。
隔离性: 多事务并发执行时，各个并发事务之间都是独立的，感觉不到其他事务的存在。
持久性: 一个事务成功完成后，对数据库的改变是持久的，即使发生系统故障。

## 并发事务带来的问题

如果不加以控制，并发的事务执行会带来一些问题，按严重程度从大到小，常见的有：

- 脏写(dirty write): 一个事务写了另一个事务之前写入但还没提交的值。
- 脏读(dirty read): 一个事务读了另一个事务之前写入但还没提交的值。
- 不可重复读(non-repeatable read): 一个事务两次读取同一个数据，中间该数据被另一个事务修改。
- 幻读(phantom): 一个事务两次读取同一个数据，中间该数据被另一个事务新增或删除。

## 隔离级别

SQL标准定义了4个隔离级别，而具体不同的DBMS在细节上会有不同的实现。

- 未提交度(read uncommitted): 最低的隔离级别，允许读取未提交的数据，可能会导致脏读，不可重复读或幻读(脏写是最严重的错误，最低的隔离级别也不允许(修改未提交的数据))。
- 已提交读(read committed): 只允许读取已提交的数据，可以防止脏读。
- 可重复读(repeatable read): 只允许读取已提交的数据，在一个事务两次读取一个数据期间，其他事务不能修改该数据，可以防止脏读和不可重复读。
- 可串行化(serializable): 最高的隔离级别，各个事务依次执行，事务之间完全不产生干扰。

MySQL的InnoDB引擎默认的隔离级别是可重复读，并且使用Next-Key Lock算法，可以避免幻读的发生，达到可串行化的效果。而大多数其他数据库，例如PostgreSQL，默认的隔离级别是已提交读。

## 悲观锁

悲观锁顾名思义，悲观地认为并发时数据会发生冲突，因此会在处理过程中对数据进行加锁，通常包括共享锁(S锁，读锁)和排它锁(X锁，写锁)，也叫作读写锁。

## 乐观锁

乐观锁不是真正的锁，而是一种并发控制的思想，最常用的使用基于时间戳/版本的控制协议。

例如基于版本的实现：为每个数据增加一个版本字段，数据每次更新将版本号加一(该操作本身也需要原子操作或者悲观锁的控制)；当读取数据时，将版本号一同读出，当提交更新时，将数据库表对应记录的版本号与之前取出来的版本号进行比对，如果相等，则予以更新，否则说明有其他事务更新了该数据，因此之前取出来的数据已过期，需要回滚重新执行该事务。

不同数据库，不同应用系统会有不同的实现，以实现不同粒度的控制。


该协议能够保证所有冲突的读写操作都能按照时间戳的大小串行执行，在执行对应的操作时不需要关注其他的事务只需要关心数据项对应时间戳的值就可以了：


无论是读操作还是写操作都会从左到右依次比较读写时间戳的值，如果小于当前值就会直接被拒绝然后回滚，数据库系统会给回滚的事务添加一个新的时间戳并重新执行这个事务。

## MVCC

数据库中通常使用MVCC(多版本并发控制)来作为一个基础的并发控制机制，简单来说，在MVCC机制下，**每一个对数据的写操作都会创建一个新版本的数据，而读操作会从多个版本的数据中挑选一个最合适的(不一定是最新的)结果返回**，这样就解决了读写锁中，只有读读可以并发，而其他(写写，读写)必须阻塞的问题。而对于MVCC来说，管理和快速挑选数据的版本就成了需要解决的主要问题。

## PostgreSQL的事务并发控制

当前最新版本为13。

PostgreSQL内部实现了三种隔离级别，因为的内部实现可以将未提交读和已提交读合并，都不允许脏读。而类似MySQL，PostgreSQL的可重复读级别也可以避免幻读的发生，而且还提到了另外一种并发事务带来的错误，称为serialization anomaly(序列化异常)，普通的"可串行化"隔离级别也无法避免这种情况的发生，所以并不是真正的可串行化。

PostgreSQL默认的隔离级别是已提交读。

Serializable Snapshot Isolation (SSI)

## InnoDB的事务并发控制

next key lock

