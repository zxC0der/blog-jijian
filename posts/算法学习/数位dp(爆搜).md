---
permalink: digital-dp-just-dfs
tags: 
  - dp
  - 数位dp
math: true
category: 算法学习
title: 数位dp(爆搜)
date: 2021-03-28 15:22:52 +0800
---

## 解决什么问题

此类题目大多数有两个特点: 区间，具有某些特征的数。

比如不含有4和连续的62(hdu2089)，比如含有13并且可以被13整除(hdu3652)，比如满足该数可以整除其数位和(hdu4389)等等...

## 如何解决

区间的问题显然很好处理，通过前缀和来解决，所以问题就是如何求出[1,n]中满足条件的数的个数(有时候0要单独考虑)。

就想标题所说的，数位dp本质就是记忆化爆搜，算法流程基本都是:

- 拆位
- 定义dp状态
- 从高位搜索，根据具体题目逻辑枚举当前位，递归边界也是根据逻辑判断是否返回有效值。
- 再加上记忆化搜索

## 代码框架

首先定义dp状态，第一维通常是指数字的位数(低i位)，其他维度需要根据不同题目定义状态，可以灵活根据空间/时间大小即将状态定义在dp数组里或者写在dfs参数里。

```cpp
ll dp[50][20];
```

然后拆位，通常是10进制的数，也有2进制或者16进制。

```cpp
void pre(ll x){
    // 数字x从低位到高位分别存放在dig[0...k-1]中
    int k=0;
    while(x){
        dig[k++]=x%10;
        x/=10;
    }
}
```

主体搜索函数，其中各个参数:

- idx表示当前枚举的位
- sta表示已枚举的前缀状态(二进制)，dif表示前缀不同数个数，这两个变量都属于状态变量，要根据不同题目设计不同状态
- lead表示当前枚举的是否是一串前导零，因为比如当数字上限是4位数，那么对于小于4位数的数来说，在搜索时实际上枚举到的数是有前导零的，比如0001，0082,0123
- 当dp计算的状态是跟数字结构无关的，比如计算数位总和，那么完全可以不考虑这个前导零，因为0001和1是一样的，但当状态跟结构或者是0的个数有关时，就需要考虑前导零的情况，比如计算不同数位的个数，那么前导零的0是不能算的。
- 递归时要根据lead && i==0来计算下一位是否还有前导零限制。
- limit表示这一位的枚举是否有限制，比如题目给的上限是185，那么当最高位枚举0，显然第二位是没有上限的，可以枚举到9，当最高位枚举1，第二位就只能枚举到8
- 递归时要根据limit && i==up来计算下一位是否有上限

```cpp
ll dfs(int idx,int sta,int dif,bool lead,bool limit){
    if(idx==-1){
        // 一个合法数字(这题要排除0)，有时候要单独考虑0的情况
        // 其实我觉得前导零的命名有点误导性，其实lead为true就是表示现在搜索的前缀是一串0
        if(dif==k && !lead){
            return 1;
        }else{
            return 0;
        }
    }
    // 记忆化的都是无上限的
    if(!limit && dp[idx][dif]!=-1){
        return dp[idx][dif];
    }
    // 这一位的枚举上限
    int up=limit?dig[idx]:15;
    ll ans=0;
    for(int i=0;i<=up;i++){
        // 具体枚举逻辑，前导零不计入不同数字个数
        if(lead && i==0 || (sta>>i)&1){
            ans+=dfs(idx-1,sta,dif,lead && i==0,limit && i==up);
        }else{
            ans+=dfs(idx-1,sta|(1<<i),dif+1,lead && i==0,limit && i==up);
        }
        ans%=mod;
    }
    if(!limit){
        dp[idx][dif]=ans%mod;
    }
    return ans%mod;
}
```

主函数调用，通常都是通过前缀和的方法来计算区间的值。

```cpp
ll solve(ll x){
pre(x);
return dfs(k-1,0,0,true,true);
}
int main(){
    // 通常dp状态只需要初始化一次
    memset(dp,-1,sizeof(dp));
    ll ans=solve(r)-solve(l-1);
    return 0;
}
```

