---
draft: true
---

> Make It Easy: An Effective End-to-End Entity Alignment Framework

实体对齐

1. 3.1最后为什么一个是等于1一个是小于等于1
可以看3.2最后，P的计算方式，可以保证每个实体即每一行肯定有一个1，就是M矩阵最大值的那个位置，但是反过来每一列就不一定了
2. 3.2最后计算Pii'的那个Mi是哪来的
就是那个Ml
3. 3.2那个Ml是怎么保证行总和等于1，列总和小于等于1
根据sinkhorn函数转换概率分布，具体见引用论文
4. confidence通常是怎么翻译
置信
5. 种子是啥，可以理解为初始参数吗？
7. 公式(4)的分母怎么保证
8. 啥叫negative pair，负采样
9. 公式(5)不懂
就一损失函数
10. 怎么学习基于结构的实体嵌入
11. 算法怎么迭代的，什么叫做减轻两个图之间的实体差异
12. 实验的那个rank是啥
就是求出来的相似度/对齐矩阵的排名，比如Hits@10就是看概率前10有没有正确答案，看这个比例


总结一下：

- 实体对齐是啥？

找出两个不同KG(知识图谱)中指向同一个现实世界对象的实体

- 这篇论文的主要工作？

提出了一种端到端的EA框架(EASY)，包括一个name-based的实体对齐程序(NEAP)，和一个structure-based的refinement(改进，提纯)策略。

- 问题描述

找出一个01矩阵，对应实体的对齐关系，1表示对应行列的实体是对齐(指向同一个对象)，行列大小分别为两个KG的实体数

- 基于name的实体对齐

首先介绍实体的两种feature，local features是首先将实体name切分为多个token，然后使用TF-IDF这种加权技术来描述每个token在实体中的不同重要性，最后得到一个矩阵E，行列大小分别是实体数量和token总数。
global features是描述两个KG的token语义相似度，行列大小是两个KG的token总数，方法就是使用一些预训练的embedding模型，每一个token可以表示为一个向量，然后求cos相似度即可

然后name-based的实体相似度矩阵Ml就可以表示为EsWstEt转置，得到的矩阵大小就是S实体数×T实体数，再用sinkhorn函数将概率分布转换，然后对于每一行，也就是S的每一个实体，找到相似度最大的那个列，就和T的对应实体对齐，这样就会导致S的每一个实体都有对齐，但是T不一定都有对齐

- 基于结构的refinement



师姐，关于论文有几个问题想请教一下：

1. 3.3(i)提到的pseudo seed不是特别理解，生成的方法能看懂，我理解就是一些在图中结构比较相似的实体对。但是具体怎么用在后面的RREA模型，需要看里面引用的那个论文吗？我现在是直接把它看成一个可以根据图结构训练出实体embedding的黑箱模型。
2. 3.3(ii)那个negative pair也不太懂大概是什么意思。
3. 公式(4)其实我看不懂为什么加上那个分母就能保证数值在[0,1]范围内，数学太差推不出来\wulian，如果不太重要的话我就先不管了\wulian
4. SRS算法迭代过程中，为什么可以"mitigate the structural difference between Gs and Gt"?意思是不断调整两个图的结构吗?
