---
draft: true
---

> 希望通过这本书，以及结合虎书(现代编译原理)和龙书(编译原理)，对编译原理进行一个简单的回顾和总结，着重放在前端部分，这部分与DSL(领域专用语言)息息相关，还是非常重要的。

> 这本书的翻译版是真的烂，英文版pdf又只有扫描版，特别老，特别难看，所以还是只能以中文版为主，英文版辅助参考了。

## 1 概论

### 什么是编译器？

编译器(Compiler)是将一种语言(源语言，Source Language)翻译为另一种语言(目标语言，Target Language)的计算机程序。

### 为什么要使用编译器？

高级语言更容易编写，阅读和理解，通过编译器翻译成机器语言，也不影响执行效率。

### C语言的编译，链接和装载过程

广义的编译过程包括预处理，编译，汇编和链接，而装载是将编译后的可执行文件加载的内存的过程。

- 预处理/预编译(Preprocessing)：包括头文件的展开，宏替换，条件编译的选择，删除注释等工作。可以使用`gcc -E a.c > a.i`来查看预编译后的文件。
- 编译(Compiling)：狭义的编译过程，将预处理生成的文件，经过词法分析，语法分析，语义分析以及优化后生成汇编语言的目标代码。可以使用`gcc -S a.i`来查看编译后的汇编文件(`a.s`)。
- 汇编(Assembly)：将汇编代码通过汇编程序转换为可执行机器指令的过程。可以使用`gcc -c a.c`直接执行预处理，编译和汇编三个步骤，生成目标obj文件(`a.o`)。
- 链接(Link)：将一个或多个目标文件链接成可执行文件，或是链接目标文件和库文件等等。例如可以使用`gcc -o ab.out a.o b.o`链接多个目标文件，生成一个可执行文件。
- 装载(Load)：简单来说，装载是在可执行文件执行时才执行的，通过确定一个程序执行的内存起始地址，将代码中访问的相对内存位置重定位为绝对位置。

### 编译的步骤

编译过程包括很多个阶段(Phase)，分别执行不同的逻辑操作，因此一个编译器也分为多个逻辑模块。

- 扫描程序(Scanner)：读入源程序，执行词法分析(Lexical Analysis)，转化为有意义的记号(Token)序列。同时可能会完成一些其他操作，比如将标识符放到符号表，将文字(Literal)放到常量表里。
- 语法分析程序(Parser)：读入词法记号流，执行语法分析(Syntax Analysis)，来定义程序结构，通常是生成分析树(Parse Tree)或者语法树(Syntax Tree)。分析树的内部节点都是抽象结构的名称，叶子节点则是输入流的词法记号，而语法树是分析树中所含信息的浓缩以及进一步抽取，所以也被称为抽象语法树(Abstract Syntax Tree,AST)。

![分析树](https://images0.cnblogs.com/blog/356524/201306/20172502-b33f908caab84c7c9c7331baa8050fd4.jpg)

![语法树](https://images0.cnblogs.com/blog/356524/201306/20173109-8c39235a6fcb43f8a66e1847100dfa06.png)

- 语义分析程序(Semantic Analyzer)：语义是语法层面之上的一种特征，可分为静态语义(static semantic)和动态语义(dynamic semantic)，显然编译器只能分析静态语义，包括声明，类型检查等，这些通过语义分析得到的额外信息称为属性(Attribute)，通常可以加到语法树上或者是符号表里。

![语义分析后的语法树](https://i.loli.net/2021/01/09/AmsP92kQtnGplEK.png)

- 源代码优化程序(Source Code Optimizer)：例如对语法树进行常量合并等一些优化，最终生成中间表示(Intermediate Representation,IR)/中间代码(常用是三元码)。
- 代码生成器(Code Generator)：输入上一步生成的IR，生成目标机器代码。
- 目标代码优化程序(Target Code Optimizer)：例如改变寄存器寻址模式，改变指令，删除多余指令等。

### 编译器的前端和后端

前端(Front End)包括只依赖源语言的部分，例如词法分析，语法分析，语义分析，中间代码生成，后端(Back End)包括只依赖目标语言的部分，例如代码生成，目标代码的优化。

### 自举

自举的定义就是用A语言所写的一个编译器可以编译A语言。要实现编译器/编程语言的自举(比如要实现Go的自举)，有以下步骤：

- 先用C写一个Go的编译器A，留下一些可以测试编译器的测试用例。
- 用Go写一个Go的编译器代码，用A编译(此时并没有用Go写的编译器，只有C写的编译器A)得到编译器B，反复修改直到通过所有测试用例。
- 用编译器B编译上一步用Go写的编译器代码得到编译器B2，反复修改直到通过所有测试用例。

也就是说，整个过程中存在了三个Go的编译器，A是C写的，B是Go写的然后由A(C)编译的，B2是Go写的然后由B(Go)编译的，这就实现了自举。

以上步骤改编自[轮子哥(vczh)知乎回答](https://www.zhihu.com/question/28513473/answer/41094452)

## 2 词法分析

### 正则表达式

正则表达式(Regular Expression)是一个模式串，所有能匹配该模式串的字符串组成的集合就是该正则表达式所生成的语言(L(r))。

正则表达式中包括正规字符(字母表中的字符，表示匹配对应字符)和元字符(比如d匹配数字)，大多数情况下，可以通过转义字符(Escape Character)来取消这种元字符的特殊含义，注意大多数语言所定义的转义字符通常也是元字符。

正则表达式的基本定义：

- 单个字符：L(**a**)={a}，L(**空**)={空}，L(**∅**)={}，注意含有空串的集合和空集的区别。
- 选择运算：L(**a**|**b**)=L(**a**)∪L(**b**)={a,b}
- 连接运算：L(**ab**)=L(**a**)L(**b**)={ab}
- 克林闭包(Kleene Closure)：也叫重复，用`*`表示，也就是字符串集的0次到无限次幂(连接)，定义0次幂为只含空串的集合。
- 优先级：克林闭包>连接>选择，通常采用括号(也是元字符)来来标识优先级。

正则表达式的拓展定义：

- 一个或多个重复：用元字符`+`表示。
- 任意字符：用元字符`.`表示。
- 字符范围：例如，用`[A-Z]`表示`A|B|...|Z`。
- 字符范围取反：用`^`表示不在该字符范围的字符。
- 可选：等同于0次或1次重复，用`?`表示。

注意并非所有串都能用正则表达式产生。

一个精确的正则表达式应该做到不误匹配也不漏匹配。

### 有穷自动机

#### 确定有穷自动机(Deterministic Finite Automaton,DFA)：

确定有穷自动机M包括字符集Σ，状态集S和状态转移函数T，状态集包括初始状态s0和接受状态集A，其中L(M)表示表示该自动机所能接受的语言，即是所有可以从开始状态通过状态转移到接受状态的字符串集合。

DFA的确定性体现在每个状态对于每个字符都只有一个确定的转移边，且没有空串的转移边。

#### 非确定有穷自动机(Nondeterministic Finite Automaton,NFA)：

NFA在DFA的基础上多了空串转移边，以及对于同一个字符可以转移到不同状态，因此转移函数T的值应该是状态集。

#### DFA的代码实现

一种比较好的实现方式是外层一个while控制状态的结束，内层通过switch/if判断当前状态，并根据字符进行转移，修改状态。状态转移表可以放在一个二维数组里，就可以实现代码层面的自动状态转移，这种方法称为表驱动(Table Driven)，该方法的缺点就是状态表会很大很稀疏，所以需要进行压缩。

#### 正则表达式转化为DFA

正则表达式和DFA是等价的，一一对应的，因此可以相互转换，实际上通常是先将正则表达式转换为NFA，再将NFA转换为DFA，最后将DFA写成上一节的程序代码，就可以实现一个扫描程序。

NFA到DFA的转换通常使用子集构造法(Subset Construction)：

- 首先定义一个状态集合的epsilon闭包，也就是集合里每个状态通过0个或多个空串能够转移到的状态构成的集合，这部分可以通过迭代法计算，让集合不断∪空串转移状态集，直到集合不再改变。
- 此时，原本的状态就应该用闭包来看待，定义NFA中一个状态集通过某一个字符的转移边能到达的状态集就等于原状态集中每一个状态，经过转移边后的状态集合(因为是NFA)**的并集的闭包**。
- 因此子集构造法的核心就是上面两个做法，从起始状态的闭包即起始状态集开始，枚举字符，求出能转移到的状态集的闭包，每个新的状态集都对应了DFA的一个新状态。

利用子集构造法生成的DFA存在的问题是状态数过多，过于复杂，根据自动机的一个理论，对于任意一个DFA，都存在一个含有最少状态的等价的DFA，且是唯一的。所以为了方便扫描程序的处理，还必须化简DFA，最小化DFA的状态数。

化简通常使用"分割法"，也就是对原来的状态集不断进行分割，将等价的状态合并，而两个状态等价的条件一是必须都为接受状态或者非接受状态(因此分割第一步一定是分为接受状态和非接受状态)，二是对于所有输入字符，都转移到等价的状态。

### 手写词法分析器

待补充

### 使用Flex生成词法分析器

待补充

## 3 语法分析

### 概述

语法分析是确定程序的结构，大多数程序的语法通常以上下文无关(Context Free)的文法规则(Grammar Rule)的形式给出，类似于词法分析中的正则表达式，但两者最大的一点不同是，**上下文无关文法是递归的**，因此分析的算法也不再是简单的扫描，分析的到的结构也不再是线性的，而大多数以树的形式出现。

文法通常采用BNF(Backus-Naur Form,巴克斯范式)的形式来描述，由左部，元字符(->或者::=)和右部组成。文法的推导就是选择某个文法规则，用右部代替左部。

### 二义性

某些文法对于一个串，可能会存在多个分析树，也就是有多种推导的顺序，这就是文法的二义性，从某种意义上讲，文法的二义性就像是一个NFA，但是暂时还不能存在一个简单的方法(例如子集构造法)可以解决二义性文法。

解决二义性的两个基本方法：

1. 设置文法之外的额外规则
2. 将文法修改为可以构造出正确格式的语法树

解决文法的二义性会涉及到优先级和结合性的问题，以运算表达式为例，优先级可以通过改变运算符文法的层次从而改变优先级，比如：

```
exp::=exp + exp | term
term::=term * term | fac
fac::=(exp) | number
```

这样的文法仍然会有二义性的问题，还需要强制指定结合性，比如：

```
exp::=exp + term | term ## 这是左结合
exp::=term + exp | term ## 这是右结合
```

另外一个经典的文法二义性问题就是悬挂else问题。

### 上下文无关文法

上下文无关文法包括终结符集合T，非终结符集合N，产生式集合P和开始符号S。其中产生式的左部是单一一个非终结符(上下文无关)，右部是终结符和非终结符组成的句型。

### 乔姆斯基文法层次

乔姆斯基层次(Chomsky hierarchy)包括4种文法：

- 0型(非限制文法)：包括所有的文法。该类型的文法能够产生所有可被图灵机识别的语言，等同于图灵机。
- 1型(上下文有关文法)：产生式规则必须是αAβ::=αγβ的形式，其中γ不能为空串。
- 2型(上下文无关文法)
- 3型(正则文法)：要求产生式的左部只能包含一个非终结符号，右部只能是空串、一个终结符号或者一个终结符号后随一个非终结符号，等同于有穷自动机。

---未完待续---
